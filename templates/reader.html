<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Shared variables */
        :root {
            --toc-width: 300px;
            --header-height: 50px;
        }

        /* Layout */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            font-family: "Georgia", serif;
            background: #fff;
        }

        /* Header / Toolbar */
        #epub-header {
            height: var(--header-height);
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            background: #2c3e50;
            flex-shrink: 0;
            z-index: 10;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-left .nav-home {
            color: #ccc;
            text-decoration: none;
            font-family: -apple-system, sans-serif;
            font-size: 0.9em;
        }

        .header-left .nav-home:hover {
            color: white;
        }

        .header-left .book-title {
            color: white;
            font-family: -apple-system, sans-serif;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 400px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn-icon {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
            border-radius: 4px;
            font-family: -apple-system, sans-serif;
        }

        .btn-icon:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .section-info {
            font-size: 0.9em;
            color: #ccc;
            min-width: 100px;
            text-align: center;
            font-family: -apple-system, sans-serif;
        }

        .header-sep {
            border-left: 1px solid #555;
            height: 20px;
            margin: 0 5px;
        }

        /* Main Content Area */
        #main-area {
            flex: 1;
            display: flex;
            flex-direction: row;
            overflow: hidden;
        }

        /* Sidebar (TOC) */
        #toc-sidebar {
            width: var(--toc-width);
            min-width: 180px;
            max-width: 500px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            padding: 20px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #toc-sidebar.hidden {
            display: none;
        }

        /* Resize handle for TOC sidebar */
        #toc-resize-handle {
            position: absolute;
            right: -5px;
            top: 0;
            bottom: 0;
            width: 10px;
            cursor: col-resize;
            z-index: 20;
            background: transparent;
        }

        #toc-resize-handle:hover {
            background: rgba(52, 152, 219, 0.3);
        }

        .nav-header {
            font-family: -apple-system, sans-serif;
            font-weight: bold;
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        /* TOC Tree */
        ul.toc-list {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }

        ul.toc-list ul {
            padding-left: 20px;
        }

        /* Indent children */
        li.toc-item {
            margin-bottom: 8px;
        }

        a.toc-link {
            text-decoration: none;
            color: #495057;
            font-size: 0.95em;
            display: block;
            padding: 4px 0;
            line-height: 1.4;
        }

        a.toc-link:hover {
            color: #000;
            text-decoration: underline;
        }

        a.toc-link.active {
            color: #d63384;
            font-weight: bold;
        }

        /* Content Area Container */
        #content-area {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: row;
        }

        /* Book Text Container - SCROLLABLE */
        .content-container {
            flex: 1;
            overflow-y: auto;
            height: 100%;
            padding: 0;
            scroll-behavior: smooth;
        }

        .book-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 50px;
            line-height: 1.8;
            font-size: 1.15em;
            color: #212529;
            /* Zoom support */
            transform-origin: top center;
            transition: transform 0.15s ease;
        }

        /* Content Styling */
        .book-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }

        .book-content h1,
        .book-content h2,
        .book-content h3 {
            font-family: -apple-system, sans-serif;
            margin-top: 1.5em;
            color: #333;
        }

        .book-content p {
            margin-bottom: 1.5em;
            text-align: justify;
        }

        /* Navigation Footer */
        .chapter-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            font-family: -apple-system, sans-serif;
        }

        .nav-btn {
            text-decoration: none;
            color: #3498db;
            font-weight: bold;
            padding: 10px 20px;
            border: 1px solid #3498db;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .nav-btn:hover {
            background: #3498db;
            color: white;
        }

        .nav-btn.disabled {
            opacity: 0.5;
            pointer-events: none;
            border-color: #ccc;
            color: #ccc;
        }
    </style>
</head>

<body>

    <!-- HEADER / TOOLBAR -->
    <header id="epub-header">
        <div class="header-left">
            <a href="/" class="nav-home">‚Üê Back</a>
            <span class="book-title" title="{{ book.metadata.title }}">{{ book.metadata.title }}</span>
        </div>

        <div class="header-controls">
            <!-- Navigation -->
            {% if prev_idx is not none %}
            <span class="btn-icon nav-prev" onclick="loadChapter({{ prev_idx }})" title="Previous Chapter"
                style="cursor:pointer;">‚óÄ</span>
            {% else %}
            <span class="btn-icon nav-prev" style="opacity:0.3; cursor:default; pointer-events:none;">‚óÄ</span>
            {% endif %}

            <span class="section-info">
                Section
                <input type="number" id="goto-section-input" value="{{ chapter_index + 1 }}" min="1"
                    max="{{ book.spine|length }}"
                    style="width: 50px; text-align: center; background: #34495e; color: white; border: 1px solid #555; border-radius: 4px; padding: 2px;">
                / {{ book.spine|length }}
                <button id="goto-btn" class="btn-icon" style="font-size: 0.8em; padding: 2px 5px;"
                    title="Go">Go</button>
            </span>

            {% if next_idx is not none %}
            <span class="btn-icon nav-next" onclick="loadChapter({{ next_idx }})" title="Next Chapter"
                style="cursor:pointer;">‚ñ∂</span>
            {% else %}
            <span class="btn-icon nav-next" style="opacity:0.3; cursor:default; pointer-events:none;">‚ñ∂</span>
            {% endif %}

            <span class="header-sep"></span>

            <!-- Zoom -->
            <button class="btn-icon" id="zoom-out" title="Zoom Out">‚àí</button>
            <button class="btn-icon" id="zoom-in" title="Zoom In">+</button>

            <span class="header-sep"></span>

            <!-- Fit controls -->
            <button class="btn-icon" id="fit-width" title="Fit Width" style="font-size: 0.8em;">‚Üî Width</button>
            <button class="btn-icon" id="fit-page" title="Fit Page" style="font-size: 0.8em;">‚Üï Page</button>

            <span class="header-sep"></span>

            <!-- ToC Toggle -->
            <button class="btn-icon" id="toggle-toc" title="Toggle Table of Contents" style="font-size: 0.8em;">üìë
                ToC</button>
        </div>

        <div style="display: flex; gap: 10px;">
            <button id="toggle-chat-btn" class="btn-icon" title="Toggle Chat"
                style="font-size: 0.9em; border: 1px solid #555;" onclick="window.RightSidebar.toggle()">üí¨
                Chat</button>
        </div>
    </header>

    <!-- MAIN AREA -->
    <div id="main-area">

        <!-- SIDEBAR (TOC) -->
        <div id="toc-sidebar">
            <div id="toc-resize-handle" title="Drag to resize"></div>
            <div class="nav-header">Table of Contents</div>

            <!-- Recursive Macro for TOC -->
            {% macro render_toc(items) %}
            <ul class="toc-list">
                {% for item in items %}
                <li class="toc-item">
                    {% set is_active = current_chapter.href == item.file_href %}
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                        class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                    {{ render_toc(item.children) }}
                    {% endif %}
                </li>
                {% endfor %}
            </ul>
            {% endmacro %}

            {{ render_toc(book.toc) }}
        </div>

        <!-- Content + Chat area -->
        <div id="content-area">
            <!-- Book Content -->
            <div class="content-container" id="content-scroll">
                <div class="book-content" id="book-content-div">
                    {{ current_chapter.content | safe }}
                </div>

                <div class="chapter-nav" style="max-width: 800px; margin: 0 auto; padding: 20px 50px 40px;">
                    {% if prev_idx is not none %}
                    <span class="nav-btn nav-prev-bottom" onclick="loadChapter({{ prev_idx }})">‚Üê Previous</span>
                    {% else %}
                    <span class="nav-btn nav-prev-bottom disabled">‚Üê Previous</span>
                    {% endif %}

                    <span style="color: #999; padding: 10px;">
                        Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                    </span>

                    {% if next_idx is not none %}
                    <span class="nav-btn nav-next-bottom" onclick="loadChapter({{ next_idx }})">Next ‚Üí</span>
                    {% else %}
                    <span class="nav-btn nav-next-bottom disabled">Next ‚Üí</span>
                    {% endif %}
                </div>
            </div>

            <!-- Set bookId before chat component so loadChatHistory can use it -->
            <!-- Data Injection: Prevent formatter errors by keeping Jinja2 out of JS logic -->
            <script type="application/json" id="reader-data">
            {
                "bookId": "{{ book_id }}",
                "initialScroll": {{ initial_scroll }},
                "initialZoom": {{ initial_zoom }},
                "chapterIndex": {{ chapter_index }},
                "totalChapters": {{ book.spine|length }},
                "spineMap": {
                    {% for ch in book.spine %}
                    "{{ ch.href }}": {{ ch.order }}{% if not loop.last %},{% endif %}
                    {% endfor %}
                }
            }
            </script>
            <script>
                try {
                    window.readerData = JSON.parse(document.getElementById('reader-data').textContent);
                    window.bookId = window.readerData.bookId;
                } catch (e) {
                    console.error("Failed to parse reader data", e);
                }
            </script>

            <!-- UNIFIED RIGHT SIDEBAR -->
            {% include "components/right_sidebar.html" %}

        </div>
    </div>

    <!-- Selection Menu (Popover) -->
    <div id="selection-menu"
        style="display:none; position:absolute; z-index:100; background:#333; color:white; padding:5px; border-radius:4px;">
        <button onclick="triggerAnnotation('highlight')">Highlight</button>
        <button onclick="triggerAskAI()">Ask AI</button>
    </div>

    <style>
        #selection-menu button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 0.9em;
        }

        #selection-menu button:hover {
            background: #555;
            border-radius: 3px;
        }

        .highlight-span {
            background-color: #ffeb3b80;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .highlight-span:hover {
            border-bottom-color: #f39c12;
        }

        .highlight-span.has-note {
            border-bottom: 2px solid #e74c3c;
        }

        .highlight-span.active {
            box-shadow: 0 0 0 2px #3498db;
            background-color: rgba(52, 152, 219, 0.3);
        }
    </style>

    <script>
        // --- State & Persistence ---
        // Data is already parsed in the block above
        const config = window.readerData || {};

        // window.bookId is already set in the previous block
        const bookId = config.bookId;

        let chapterIndex = config.chapterIndex;
        let currentZoom = config.initialZoom;
        const totalChapters = config.totalChapters;
        const spineMap = config.spineMap || {};

        const zoomStep = 10;
        const minZoom = 50;
        const maxZoom = 200;
        const bookContentDiv = document.getElementById('book-content-div');
        const contentScroll = document.getElementById('content-scroll');

        // Restore Scroll Position
        window.addEventListener('load', () => {
            const initScroll = config.initialScroll;
            if (initScroll > 0) {
                contentScroll.scrollTop = initScroll;
            }
            applyZoom();
        });

        // Save Progress
        let saveTimeout;
        function saveProgress() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                fetch(`/api/progress/${bookId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: chapterIndex,
                        page_num: 1, // Not used for EPUB but consistent
                        scroll_position: contentScroll.scrollTop,
                        zoom: currentZoom
                    })
                });
            }, 1000);
        }

        function debounceSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveProgress, 1000);
        }

        // Event Listeners for Saving
        contentScroll.addEventListener('scroll', debounceSave);

        function applyZoom() {
            const scaleFactor = currentZoom / 100;
            bookContentDiv.style.transform = `scale(${scaleFactor})`;
            // Adjust wrapper for layout
            bookContentDiv.style.transformOrigin = 'top center';
            debounceSave(); // Save zoom change
        }

        document.getElementById('zoom-in').addEventListener('click', function () {
            if (currentZoom < maxZoom) {
                currentZoom += zoomStep;
                applyZoom();
            }
        });

        document.getElementById('zoom-out').addEventListener('click', function () {
            if (currentZoom > minZoom) {
                currentZoom -= zoomStep;
                applyZoom();
            }
        });

        // --- Fit Width ---
        document.getElementById('fit-width').addEventListener('click', function () {
            const containerWidth = contentScroll.clientWidth;
            const contentNaturalWidth = 800 + 100; // max-width + padding
            const scaleNeeded = containerWidth / contentNaturalWidth;
            currentZoom = Math.round(Math.min(scaleNeeded, 2.0) * 100);
            currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom));
            applyZoom();
        });

        // --- Fit Page (fit content height to viewport) ---
        document.getElementById('fit-page').addEventListener('click', function () {
            // Reset zoom first to measure natural height
            bookContentDiv.style.transform = 'none';
            const naturalHeight = bookContentDiv.scrollHeight;
            const containerHeight = contentScroll.clientHeight;
            const containerWidth = contentScroll.clientWidth;
            const contentNaturalWidth = 800 + 100;

            const scaleH = containerHeight / naturalHeight;
            const scaleW = containerWidth / contentNaturalWidth;
            const scaleFit = Math.min(scaleH, scaleW);

            currentZoom = Math.round(Math.min(scaleFit, 2.0) * 100);
            currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom));
            applyZoom();
        });

        // --- Toggle ToC ---
        const tocSidebar = document.getElementById('toc-sidebar');
        document.getElementById('toggle-toc').addEventListener('click', function () {
            tocSidebar.classList.toggle('hidden');
        });

        // --- Resizable ToC Sidebar ---
        const tocResizeHandle = document.getElementById('toc-resize-handle');
        let isTocResizing = false;

        tocResizeHandle.addEventListener('mousedown', function (e) {
            isTocResizing = true;
            document.body.style.cursor = 'col-resize';
            e.preventDefault();
        });

        document.addEventListener('mousemove', function (e) {
            if (!isTocResizing) return;
            let newWidth = e.clientX;
            if (newWidth < 180) newWidth = 180;
            if (newWidth > 500) newWidth = 500;
            document.documentElement.style.setProperty('--toc-width', newWidth + 'px');
        });

        document.addEventListener('mouseup', function () {
            if (isTocResizing) {
                isTocResizing = false;
                document.body.style.cursor = '';
            }
        });

        // --- TOC Navigation Logic ---
        // spineMap is already loaded from config above

        // ==============================================
        // AJAX Chapter Loading (no full page reload)
        // ==============================================
        async function loadChapter(idx, anchor) {
            if (idx < 0 || idx >= totalChapters) return;

            try {
                const resp = await fetch(`/api/chapter/${bookId}/${idx}`);
                if (!resp.ok) {
                    console.error("Failed to load chapter", idx, resp.status);
                    return;
                }
                const data = await resp.json();

                // 1. Swap content
                bookContentDiv.innerHTML = data.content;

                // 2. Update JS state
                chapterIndex = data.chapter_index;

                // 3. Update URL bar (without reload)
                const newUrl = `/read/${bookId}/${chapterIndex}` + (anchor ? '#' + anchor : '');
                history.pushState({ chapterIndex: chapterIndex }, '', newUrl);

                // 4. Update navigation UI
                updateNavUI(data.prev_idx, data.next_idx);

                // 5. Update ToC active highlight
                updateTocHighlight(data.href);

                // 6. Scroll to anchor or top
                if (anchor) {
                    const target = document.getElementById(anchor);
                    if (target) {
                        target.scrollIntoView();
                    } else {
                        contentScroll.scrollTop = 0;
                    }
                } else {
                    contentScroll.scrollTop = 0;
                }

                // 7. Re-apply zoom (already set, just ensure transform is correct)
                applyZoom();

                // 8. Save progress immediately
                saveProgress();

            } catch (err) {
                console.error("Error loading chapter:", err);
            }
        }

        function updateNavUI(prevIdx, nextIdx) {
            // Update section counter
            const gotoInput = document.getElementById('goto-section-input');
            gotoInput.value = chapterIndex + 1;

            // Update section info text in bottom nav
            const bottomInfo = document.querySelector('.chapter-nav span[style]');
            if (bottomInfo) {
                bottomInfo.textContent = `Section ${chapterIndex + 1} of ${totalChapters}`;
            }

            // Update header prev/next buttons
            const headerControls = document.querySelector('.header-controls');
            const prevBtn = headerControls.querySelector('.nav-prev');
            const nextBtn = headerControls.querySelector('.nav-next');

            if (prevBtn) {
                if (prevIdx !== null && prevIdx !== undefined) {
                    prevBtn.style.opacity = '';
                    prevBtn.style.cursor = 'pointer';
                    prevBtn.style.pointerEvents = '';
                    prevBtn.onclick = (e) => { e.preventDefault(); loadChapter(prevIdx); };
                } else {
                    prevBtn.style.opacity = '0.3';
                    prevBtn.style.cursor = 'default';
                    prevBtn.style.pointerEvents = 'none';
                    prevBtn.onclick = null;
                }
            }

            if (nextBtn) {
                if (nextIdx !== null && nextIdx !== undefined) {
                    nextBtn.style.opacity = '';
                    nextBtn.style.cursor = '';
                    nextBtn.style.pointerEvents = '';
                    nextBtn.onclick = (e) => { e.preventDefault(); loadChapter(nextIdx); };
                } else {
                    nextBtn.style.opacity = '0.3';
                    nextBtn.style.cursor = 'default';
                    nextBtn.style.pointerEvents = 'none';
                    nextBtn.onclick = null;
                }
            }

            // Update bottom prev/next buttons
            const bottomNav = document.querySelector('.chapter-nav');
            if (bottomNav) {
                const bottomPrev = bottomNav.querySelector('.nav-prev-bottom');
                const bottomNext = bottomNav.querySelector('.nav-next-bottom');

                if (bottomPrev) {
                    if (prevIdx !== null && prevIdx !== undefined) {
                        bottomPrev.className = 'nav-btn nav-prev-bottom';
                        bottomPrev.onclick = (e) => { e.preventDefault(); loadChapter(prevIdx); };
                    } else {
                        bottomPrev.className = 'nav-btn nav-prev-bottom disabled';
                        bottomPrev.onclick = null;
                    }
                }

                if (bottomNext) {
                    if (nextIdx !== null && nextIdx !== undefined) {
                        bottomNext.className = 'nav-btn nav-next-bottom';
                        bottomNext.onclick = (e) => { e.preventDefault(); loadChapter(nextIdx); };
                    } else {
                        bottomNext.className = 'nav-btn nav-next-bottom disabled';
                        bottomNext.onclick = null;
                    }
                }
            }
        }

        function updateTocHighlight(currentHref) {
            // Remove all active classes
            document.querySelectorAll('a.toc-link.active').forEach(el => {
                el.classList.remove('active');
            });
            // Find and activate matching link
            document.querySelectorAll('a.toc-link').forEach(el => {
                const onclick = el.getAttribute('onclick');
                if (onclick && onclick.includes(currentHref)) {
                    el.classList.add('active');
                }
            });
        }

        // --- Browser back/forward support ---
        window.addEventListener('popstate', function (e) {
            if (e.state && e.state.chapterIndex !== undefined) {
                // Use loadChapterNoHistory to avoid pushing duplicate state
                loadChapterNoHistory(e.state.chapterIndex);
            }
        });

        async function loadChapterNoHistory(idx) {
            if (idx < 0 || idx >= totalChapters) return;
            try {
                const resp = await fetch(`/api/chapter/${bookId}/${idx}`);
                if (!resp.ok) return;
                const data = await resp.json();

                bookContentDiv.innerHTML = data.content;
                chapterIndex = data.chapter_index;
                updateNavUI(data.prev_idx, data.next_idx);
                updateTocHighlight(data.href);
                contentScroll.scrollTop = 0;
                applyZoom();
                saveProgress();
            } catch (err) {
                console.error("Error loading chapter:", err);
            }
        }

        // Set initial history state
        history.replaceState({ chapterIndex: chapterIndex }, '');

        function findAndGo(filename) {
            // cleanup anchor
            let cleanFile = filename.split('#')[0];
            // Decode URI just in case (e.g. spaces -> %20)
            try { cleanFile = decodeURIComponent(cleanFile); } catch (e) { }

            let idx = spineMap[cleanFile];

            // Robust Fallback: try matching basename if full path fails
            if (idx === undefined) {
                const basename = cleanFile.split('/').pop();
                for (const key in spineMap) {
                    if (key.endsWith(basename)) {
                        idx = spineMap[key];
                        break;
                    }
                }
            }

            if (idx !== undefined) {
                // Extract anchor from original filename
                const anchor = filename.includes('#') ? filename.split('#')[1] : '';
                loadChapter(idx, anchor);
            } else {
                console.error("Could not find index for", filename);
                // Don't alert for same-page anchors
                if (filename.startsWith('#')) {
                    window.location.hash = filename;
                } else {
                    console.warn("Could not find chapter: " + filename);
                }
            }
        }

        // --- Intercept internal content links ---
        // Use event delegation on content-scroll so it works after content swap
        document.getElementById('content-scroll').addEventListener('click', function (e) {
            const link = e.target.closest('a');
            if (!link) return;

            // Only intercept links inside book content, not nav buttons
            if (!document.getElementById('book-content-div').contains(link)) return;

            const href = link.getAttribute('href');
            if (!href) return;

            // Skip external links
            if (/^[a-z]+:\/\//i.test(href) || href.startsWith('mailto:')) return;

            // Internal link ‚Äî intercept it
            e.preventDefault();
            findAndGo(href);
        });

        // --- Text Selection Hook for Chat (Legacy) ---
        // We override this with new Annotation Logic

        // --- Annotation System ---
        const selectionMenu = document.getElementById('selection-menu');

        document.addEventListener('mouseup', (e) => {
            const selection = window.getSelection();
            if (selection.toString().trim().length > 0) {
                // If selection is inside book content
                const contentDiv = document.getElementById('book-content-div');
                if (contentDiv.contains(selection.anchorNode)) {
                    // Show menu
                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();

                    selectionMenu.style.display = 'flex';
                    selectionMenu.style.top = (window.scrollY + rect.top - 40) + 'px';
                    selectionMenu.style.left = (window.scrollX + rect.left + rect.width / 2 - 75) + 'px';
                    return;
                }
            }
            // Hide if clicked elsewhere, BUT check if clicking menu itself
            if (!selectionMenu.contains(e.target)) {
                selectionMenu.style.display = 'none';
            }
        });

        // Current temporary selection state
        function getSelectedQuote() {
            const selection = window.getSelection();
            return selection.toString().trim();
        }

        async function triggerAnnotation(type) {
            const quote = getSelectedQuote();
            if (!quote) return;

            selectionMenu.style.display = 'none';

            // Create annotation
            const payload = {
                type: (type === 'ask') ? 'chat_thread' : type, // 'ask' starts a chat thread
                target: {
                    chapter_index: chapterIndex,
                    quote: quote
                },
                content: {
                    text: (type === 'note') ? "New Note" : "", // placeholder
                    color: "yellow"
                }
            };

            try {
                const resp = await fetch(`/api/annotations/${bookId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await resp.json();

                // Refresh highlights
                await loadAnnotations();

                // If Note or Ask, open sidebar immediately
                if (type === 'note') {
                    window.RightSidebar.openThread(data.id);
                }
                // Ask is now handled by triggerAskAI
            } catch (e) {
                console.error("Failed to create annotation", e);
            }
        }

        function triggerAskAI() {
            const selection = window.getSelection();
            const text = selection.toString().trim();

            // Clean up selection menu
            document.getElementById('selection-menu').style.display = 'none';

            if (text) {
                if (window.RightSidebar && window.RightSidebar.openGlobalChat) {
                    window.RightSidebar.openGlobalChat(text);
                } else {
                    console.error("RightSidebar.openGlobalChat not available");
                }
            }
        }



        // --- Rendering Logic (Quote Matching) ---
        let currentAnnotations = [];

        async function loadAnnotations() {
            try {
                const resp = await fetch(`/api/annotations/${bookId}`);
                const annotations = await resp.json();
                currentAnnotations = annotations;
                renderHighlights(annotations);
                renderSidebarList(annotations);
            } catch (e) { console.error(e); }
        }

        window.loadAnnotationsList = loadAnnotations;
        window.reloadAnnotations = loadAnnotations;

        function renderHighlights(annotations) {
            document.querySelectorAll('.highlight-span').forEach(span => {
                const parent = span.parentNode;
                parent.replaceChild(document.createTextNode(span.textContent), span);
                parent.normalize();
            });

            const chapterAnns = annotations.filter(a => a.target.chapter_index === chapterIndex);
            const contentDiv = document.getElementById('book-content-div');
            if (!contentDiv) return;

            function normalizeWs(s) {
                return (s || '').replace(/\s+/g, ' ').trim();
            }
            function findRangeForQuote(root, quote) {
                const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
                const nodes = [];
                let totalLen = 0;
                let node;
                while (node = walker.nextNode()) {
                    const len = node.nodeValue.length;
                    nodes.push({ node: node, start: totalLen, end: totalLen + len });
                    totalLen += len;
                }
                const fullText = nodes.map(n => n.node.nodeValue).join('');
                let idx = fullText.indexOf(quote);
                let endIdx = idx === -1 ? -1 : idx + quote.length;

                if (idx === -1) {
                    const fullNorm = normalizeWs(fullText);
                    const quoteNorm = normalizeWs(quote);
                    if (!quoteNorm) return null;
                    const idxNorm = fullNorm.indexOf(quoteNorm);
                    if (idxNorm === -1) return null;
                    const endNorm = idxNorm + quoteNorm.length;
                    const origToNorm = [];
                    let normPos = 0;
                    for (let i = 0; i < fullText.length; i++) {
                        origToNorm[i] = normPos;
                        if (!/\s/.test(fullText[i])) normPos++;
                        else if (i === 0 || !/\s/.test(fullText[i - 1])) normPos++;
                    }
                    let startOrig = fullText.length, endOrig = fullText.length;
                    for (let i = 0; i < fullText.length; i++) {
                        if (origToNorm[i] === idxNorm) { startOrig = i; break; }
                    }
                    for (let i = 0; i < fullText.length; i++) {
                        if (origToNorm[i] >= endNorm) { endOrig = i; break; }
                    }
                    idx = startOrig;
                    endIdx = endOrig;
                } else {
                    endIdx = idx + quote.length;
                }

                let startNode = null, startOff = 0, endNode = null, endOff = 0;
                for (let i = 0; i < nodes.length; i++) {
                    if (idx >= nodes[i].start && idx < nodes[i].end) {
                        startNode = nodes[i].node;
                        startOff = idx - nodes[i].start;
                    }
                    if (endIdx > nodes[i].start && endIdx <= nodes[i].end) {
                        endNode = nodes[i].node;
                        endOff = endIdx - nodes[i].start;
                    }
                }
                if (!startNode || !endNode) return null;
                const range = document.createRange();
                range.setStart(startNode, startOff);
                range.setEnd(endNode, endOff);
                return range;
            }

            chapterAnns.forEach(ann => {
                if (!ann.target || !ann.target.quote) return;

                const quote = ann.target.quote;
                const range = findRangeForQuote(contentDiv, quote);
                if (!range) return;

                const span = document.createElement('span');
                span.className = 'highlight-span';
                if (ann.type !== 'highlight') span.classList.add('has-note');
                span.dataset.id = ann.id;
                span.style.backgroundColor = 'rgba(255, 235, 59, 0.6)';
                if (ann.type !== 'highlight') span.style.backgroundColor = 'rgba(221, 221, 221, 0.85)';
                span.style.cursor = 'pointer';

                span.onclick = (e) => {
                    e.stopPropagation();
                    window.activateHighlight(ann.id);
                    if (window.RightSidebar) window.RightSidebar.open();
                };

                try {
                    const fragment = range.extractContents();
                    span.appendChild(fragment);
                    range.insertNode(span);
                } catch (err) { /* fallback: single-node wrap */ }
            });
        }

        async function updateAnnotationContent(id, newText) {
            try {
                // Find current
                const resp = await fetch(`/api/annotations/${bookId}`);
                const all = await resp.json();
                const target = all.find(a => a.id === id);
                if (!target) return;

                target.content.text = newText;

                await fetch(`/api/annotations/${bookId}/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(target)
                });

                await loadAnnotations();
            } catch (e) { console.error(e); }
        }
        window.updateAnnotationContent = updateAnnotationContent;

        function renderSidebarList(annotations) {
            const listContainer = document.getElementById('annotations-list-container');
            if (!listContainer) return;

            const chapterAnns = annotations.filter(a => (a.target && a.target.chapter_index != null) && a.target.chapter_index === chapterIndex);
            if (chapterAnns.length === 0) {
                listContainer.innerHTML = '<div style="padding:20px; color:#999; text-align:center;">No annotations in this section.</div>';
                return;
            }

            listContainer.innerHTML = chapterAnns.map(a => {
                const ch = (a.target && a.target.chapter_index != null) ? a.target.chapter_index + 1 : '?';
                return `
                <div class="annotation-item" onclick="window.activateHighlight('${a.id}')" data-id="${a.id}">
                    <div class="annotation-quote">Section ${ch}: "${(a.target && a.target.quote ? a.target.quote : "").substring(0, 50)}..."</div>
                    <div class="annotation-note-preview">
                        ${a.content && a.content.text ? marked.parse(a.content.text) : '<span style="color:#ccc;font-style:italic;">No note</span>'}
                    </div>
                    <div class="annotation-meta" style="margin-top:5px; align-items:center;">
                        <span>${new Date(a.created_at).toLocaleTimeString()}</span>
                        <div class="actions">
                            <button class="ann-edit-btn" data-id="${a.id}" title="Edit">‚úèÔ∏è</button>
                            <button class="ann-delete-btn" data-id="${a.id}" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                </div>
                `;
            }).join('');

            listContainer.querySelectorAll('.ann-edit-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const ann = currentAnnotations.find(x => x.id === btn.dataset.id);
                    window.RightSidebar.startEdit(btn.dataset.id, ann && ann.content ? (ann.content.text || '') : '');
                });
            });
            listContainer.querySelectorAll('.ann-delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    window.RightSidebar.deleteAnnotation(btn.dataset.id);
                });
            });
        }

        // --- Thread View Logic ---
        let currentThreadId = null;
        window.loadAnnotationThread = async (annId) => {
            currentThreadId = annId;
            const resp = await fetch(`/api/annotations/${bookId}`);
            const all = await resp.json();
            const ann = all.find(a => a.id === annId);

            if (!ann) return;

            // Store for Edit logic
            window.currentAnnotation = ann;

            document.getElementById('thread-title').textContent = ann.type === 'chat_thread' ? 'Discussion' : 'Note';
            document.getElementById('thread-placeholder').style.display = 'none';

            // Render Note Content (Markdown)
            const noteDisplay = document.getElementById('thread-note-display');
            if (ann.content.text) {
                noteDisplay.style.display = 'block';
                noteDisplay.innerHTML = marked.parse(ann.content.text);
            } else {
                noteDisplay.style.display = 'none';
            }

            // Mount Chat if needed
            // TODO: Reuse Chat Component Logic via a bridge
            // For now, let's just show raw messages or placeholder
            // In a real app we'd re-instantiate the Vue/React component or clean JS class
        };

        // Highlight Activation: go to chapter if needed, then scroll to highlight
        window.activateHighlight = async function (annId) {
            document.querySelectorAll('.highlight-span.active').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.annotation-item.active').forEach(el => el.classList.remove('active'));

            const ann = currentAnnotations.find(a => a.id === annId);
            const targetChapter = ann && ann.target && (ann.target.chapter_index != null) ? ann.target.chapter_index : null;

            if (targetChapter != null && targetChapter !== chapterIndex) {
                await loadChapter(targetChapter);
                await loadAnnotations();
            }

            const target = document.querySelector(`.highlight-span[data-id="${annId}"]`);
            if (target) {
                target.classList.add('active');
                target.scrollIntoView({ behavior: "smooth", block: "center" });
            }

            const sidebarItem = document.querySelector(`.annotation-item[data-id="${annId}"]`);
            if (sidebarItem) {
                sidebarItem.classList.add('active');
                sidebarItem.scrollIntoView({ behavior: "smooth", block: "center" });
            }
        }

        // Load initially
        window.addEventListener('load', loadAnnotations);

        // Reload when chapter changes (hooking into loadChapter)
        const originalLoadChapter = loadChapter;
        loadChapter = async function (idx, anchor) {
            await originalLoadChapter(idx, anchor);
            await loadAnnotations();
        };


        // --- Go To Section Logic ---
        const gotoInput = document.getElementById('goto-section-input');
        const gotoBtn = document.getElementById('goto-btn');

        function handleGoTo() {
            const val = parseInt(gotoInput.value);
            if (val && val >= 1 && val <= totalChapters) {
                loadChapter(val - 1);
            } else {
                alert("Invalid section number");
            }
        }

        gotoBtn.addEventListener('click', handleGoTo);
        gotoInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleGoTo();
        });

    </script>
</body>

</html>