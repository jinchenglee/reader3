<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Shared variables */
        :root {
            --toc-width: 300px;
            --header-height: 50px;
        }

        /* Layout */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            font-family: "Georgia", serif;
            background: #fff;
        }

        /* Header / Toolbar */
        #epub-header {
            height: var(--header-height);
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            background: #2c3e50;
            flex-shrink: 0;
            z-index: 10;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-left .nav-home {
            color: #ccc;
            text-decoration: none;
            font-family: -apple-system, sans-serif;
            font-size: 0.9em;
        }

        .header-left .nav-home:hover {
            color: white;
        }

        .header-left .book-title {
            color: white;
            font-family: -apple-system, sans-serif;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 400px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn-icon {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
            border-radius: 4px;
            font-family: -apple-system, sans-serif;
        }

        .btn-icon:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .section-info {
            font-size: 0.9em;
            color: #ccc;
            min-width: 100px;
            text-align: center;
            font-family: -apple-system, sans-serif;
        }

        .header-sep {
            border-left: 1px solid #555;
            height: 20px;
            margin: 0 5px;
        }

        /* Main Content Area */
        #main-area {
            flex: 1;
            display: flex;
            flex-direction: row;
            overflow: hidden;
        }

        /* Sidebar (TOC) */
        #toc-sidebar {
            width: var(--toc-width);
            min-width: 180px;
            max-width: 500px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            padding: 20px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #toc-sidebar.hidden {
            display: none;
        }

        /* Resize handle for TOC sidebar */
        #toc-resize-handle {
            position: absolute;
            right: -5px;
            top: 0;
            bottom: 0;
            width: 10px;
            cursor: col-resize;
            z-index: 20;
            background: transparent;
        }

        #toc-resize-handle:hover {
            background: rgba(52, 152, 219, 0.3);
        }

        .nav-header {
            font-family: -apple-system, sans-serif;
            font-weight: bold;
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        /* TOC Tree */
        ul.toc-list {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }

        ul.toc-list ul {
            padding-left: 20px;
        }

        /* Indent children */
        li.toc-item {
            margin-bottom: 8px;
        }

        a.toc-link {
            text-decoration: none;
            color: #495057;
            font-size: 0.95em;
            display: block;
            padding: 4px 0;
            line-height: 1.4;
        }

        a.toc-link:hover {
            color: #000;
            text-decoration: underline;
        }

        a.toc-link.active {
            color: #d63384;
            font-weight: bold;
        }

        /* Content Area Container */
        #content-area {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: row;
        }

        /* Book Text Container - SCROLLABLE */
        .content-container {
            flex: 1;
            overflow-y: auto;
            height: 100%;
            padding: 0;
            scroll-behavior: smooth;
        }

        .book-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 50px;
            line-height: 1.8;
            font-size: 1.15em;
            color: #212529;
            /* Zoom support */
            transform-origin: top center;
            transition: transform 0.15s ease;
        }

        /* Content Styling */
        .book-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }

        .book-content h1,
        .book-content h2,
        .book-content h3 {
            font-family: -apple-system, sans-serif;
            margin-top: 1.5em;
            color: #333;
        }

        .book-content p {
            margin-bottom: 1.5em;
            text-align: justify;
        }

        /* Navigation Footer */
        .chapter-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            font-family: -apple-system, sans-serif;
        }

        .nav-btn {
            text-decoration: none;
            color: #3498db;
            font-weight: bold;
            padding: 10px 20px;
            border: 1px solid #3498db;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .nav-btn:hover {
            background: #3498db;
            color: white;
        }

        .nav-btn.disabled {
            opacity: 0.5;
            pointer-events: none;
            border-color: #ccc;
            color: #ccc;
        }
    </style>
</head>

<body>

    <!-- HEADER / TOOLBAR -->
    <header id="epub-header">
        <div class="header-left">
            <a href="/" class="nav-home">‚Üê Back</a>
            <span class="book-title" title="{{ book.metadata.title }}">{{ book.metadata.title }}</span>
        </div>

        <div class="header-controls">
            <!-- Navigation -->
            {% if prev_idx is not none %}
            <span class="btn-icon nav-prev" onclick="loadChapter({{ prev_idx }})" title="Previous Chapter"
                style="cursor:pointer;">‚óÄ</span>
            {% else %}
            <span class="btn-icon nav-prev" style="opacity:0.3; cursor:default; pointer-events:none;">‚óÄ</span>
            {% endif %}

            <span class="section-info">
                Section
                <input type="number" id="goto-section-input" value="{{ chapter_index + 1 }}" min="1"
                    max="{{ book.spine|length }}"
                    style="width: 50px; text-align: center; background: #34495e; color: white; border: 1px solid #555; border-radius: 4px; padding: 2px;">
                / {{ book.spine|length }}
                <button id="goto-btn" class="btn-icon" style="font-size: 0.8em; padding: 2px 5px;"
                    title="Go">Go</button>
            </span>

            {% if next_idx is not none %}
            <span class="btn-icon nav-next" onclick="loadChapter({{ next_idx }})" title="Next Chapter"
                style="cursor:pointer;">‚ñ∂</span>
            {% else %}
            <span class="btn-icon nav-next" style="opacity:0.3; cursor:default; pointer-events:none;">‚ñ∂</span>
            {% endif %}

            <span class="header-sep"></span>

            <!-- Zoom -->
            <button class="btn-icon" id="zoom-out" title="Zoom Out">‚àí</button>
            <button class="btn-icon" id="zoom-in" title="Zoom In">+</button>

            <span class="header-sep"></span>

            <!-- Fit controls -->
            <button class="btn-icon" id="fit-width" title="Fit Width" style="font-size: 0.8em;">‚Üî Width</button>
            <button class="btn-icon" id="fit-page" title="Fit Page" style="font-size: 0.8em;">‚Üï Page</button>

            <span class="header-sep"></span>

            <!-- ToC Toggle -->
            <button class="btn-icon" id="toggle-toc" title="Toggle Table of Contents" style="font-size: 0.8em;">üìë
                ToC</button>
        </div>

        <div style="display: flex; gap: 10px;">
            <button id="toggle-chat-btn" class="btn-icon" title="Toggle Chat"
                style="font-size: 0.9em; border: 1px solid #555;">üí¨ Chat</button>
        </div>
    </header>

    <!-- MAIN AREA -->
    <div id="main-area">

        <!-- SIDEBAR (TOC) -->
        <div id="toc-sidebar">
            <div id="toc-resize-handle" title="Drag to resize"></div>
            <div class="nav-header">Table of Contents</div>

            <!-- Recursive Macro for TOC -->
            {% macro render_toc(items) %}
            <ul class="toc-list">
                {% for item in items %}
                <li class="toc-item">
                    {% set is_active = current_chapter.href == item.file_href %}
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                        class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                    {{ render_toc(item.children) }}
                    {% endif %}
                </li>
                {% endfor %}
            </ul>
            {% endmacro %}

            {{ render_toc(book.toc) }}
        </div>

        <!-- Content + Chat area -->
        <div id="content-area">
            <!-- Book Content -->
            <div class="content-container" id="content-scroll">
                <div class="book-content" id="book-content-div">
                    {{ current_chapter.content | safe }}
                </div>

                <div class="chapter-nav" style="max-width: 800px; margin: 0 auto; padding: 20px 50px 40px;">
                    {% if prev_idx is not none %}
                    <span class="nav-btn nav-prev-bottom" onclick="loadChapter({{ prev_idx }})">‚Üê Previous</span>
                    {% else %}
                    <span class="nav-btn nav-prev-bottom disabled">‚Üê Previous</span>
                    {% endif %}

                    <span style="color: #999; padding: 10px;">
                        Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                    </span>

                    {% if next_idx is not none %}
                    <span class="nav-btn nav-next-bottom" onclick="loadChapter({{ next_idx }})">Next ‚Üí</span>
                    {% else %}
                    <span class="nav-btn nav-next-bottom disabled">Next ‚Üí</span>
                    {% endif %}
                </div>
            </div>

            <!-- CHAT SIDEBAR (Shared) -->
            {% include "components/chat_component.html" %}

        </div>
    </div>

    <script>
        // --- State & Persistence ---
        const bookId = "{{ book_id }}";
        let chapterIndex = {{ chapter_index }};
        let currentZoom = {{ initial_zoom }}; // Restore zoom
        const totalChapters = {{ book.spine|length }};

        const zoomStep = 10;
        const minZoom = 50;
        const maxZoom = 200;
        const bookContentDiv = document.getElementById('book-content-div');
        const contentScroll = document.getElementById('content-scroll');

        // Restore Scroll Position
        window.addEventListener('load', () => {
            const initScroll = {{ initial_scroll }};
            if (initScroll > 0) {
                contentScroll.scrollTop = initScroll;
            }
            applyZoom(); // Apply initial zoom
        });

        // Save Progress
        let saveTimeout;
        function saveProgress() {
            const data = {
                chapter_index: chapterIndex,
                page_num: 1, // Not used for EPUB but consistent
                scroll_position: contentScroll.scrollTop,
                zoom: currentZoom
            };

            fetch(`/api/progress/${bookId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            }).catch(console.error);
        }

        function debounceSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveProgress, 1000);
        }

        // Event Listeners for Saving
        contentScroll.addEventListener('scroll', debounceSave);

        function applyZoom() {
            const scaleFactor = currentZoom / 100;
            bookContentDiv.style.transform = `scale(${scaleFactor})`;
            // Adjust wrapper for layout
            bookContentDiv.style.transformOrigin = 'top center';
            debounceSave(); // Save zoom change
        }

        document.getElementById('zoom-in').addEventListener('click', function () {
            if (currentZoom < maxZoom) {
                currentZoom += zoomStep;
                applyZoom();
            }
        });

        document.getElementById('zoom-out').addEventListener('click', function () {
            if (currentZoom > minZoom) {
                currentZoom -= zoomStep;
                applyZoom();
            }
        });

        // --- Fit Width ---
        document.getElementById('fit-width').addEventListener('click', function () {
            const containerWidth = contentScroll.clientWidth;
            const contentNaturalWidth = 800 + 100; // max-width + padding
            const scaleNeeded = containerWidth / contentNaturalWidth;
            currentZoom = Math.round(Math.min(scaleNeeded, 2.0) * 100);
            currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom));
            applyZoom();
        });

        // --- Fit Page (fit content height to viewport) ---
        document.getElementById('fit-page').addEventListener('click', function () {
            // Reset zoom first to measure natural height
            bookContentDiv.style.transform = 'none';
            const naturalHeight = bookContentDiv.scrollHeight;
            const containerHeight = contentScroll.clientHeight;
            const containerWidth = contentScroll.clientWidth;
            const contentNaturalWidth = 800 + 100;

            const scaleH = containerHeight / naturalHeight;
            const scaleW = containerWidth / contentNaturalWidth;
            const scaleFit = Math.min(scaleH, scaleW);

            currentZoom = Math.round(Math.min(scaleFit, 2.0) * 100);
            currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom));
            applyZoom();
        });

        // --- Toggle ToC ---
        const tocSidebar = document.getElementById('toc-sidebar');
        document.getElementById('toggle-toc').addEventListener('click', function () {
            tocSidebar.classList.toggle('hidden');
        });

        // --- Resizable ToC Sidebar ---
        const tocResizeHandle = document.getElementById('toc-resize-handle');
        let isTocResizing = false;

        tocResizeHandle.addEventListener('mousedown', function (e) {
            isTocResizing = true;
            document.body.style.cursor = 'col-resize';
            e.preventDefault();
        });

        document.addEventListener('mousemove', function (e) {
            if (!isTocResizing) return;
            let newWidth = e.clientX;
            if (newWidth < 180) newWidth = 180;
            if (newWidth > 500) newWidth = 500;
            document.documentElement.style.setProperty('--toc-width', newWidth + 'px');
        });

        document.addEventListener('mouseup', function () {
            if (isTocResizing) {
                isTocResizing = false;
                document.body.style.cursor = '';
            }
        });

        // --- TOC Navigation Logic ---
        const spineMap = {
            {% for ch in book.spine %}
        "{{ ch.href }}": {{ ch.order }},
        {% endfor %}
        };

        // ==============================================
        // AJAX Chapter Loading (no full page reload)
        // ==============================================
        async function loadChapter(idx, anchor) {
            if (idx < 0 || idx >= totalChapters) return;

            try {
                const resp = await fetch(`/api/chapter/${bookId}/${idx}`);
                if (!resp.ok) {
                    console.error("Failed to load chapter", idx, resp.status);
                    return;
                }
                const data = await resp.json();

                // 1. Swap content
                bookContentDiv.innerHTML = data.content;

                // 2. Update JS state
                chapterIndex = data.chapter_index;

                // 3. Update URL bar (without reload)
                const newUrl = `/read/${bookId}/${chapterIndex}` + (anchor ? '#' + anchor : '');
                history.pushState({ chapterIndex: chapterIndex }, '', newUrl);

                // 4. Update navigation UI
                updateNavUI(data.prev_idx, data.next_idx);

                // 5. Update ToC active highlight
                updateTocHighlight(data.href);

                // 6. Scroll to anchor or top
                if (anchor) {
                    const target = document.getElementById(anchor);
                    if (target) {
                        target.scrollIntoView();
                    } else {
                        contentScroll.scrollTop = 0;
                    }
                } else {
                    contentScroll.scrollTop = 0;
                }

                // 7. Re-apply zoom (already set, just ensure transform is correct)
                applyZoom();

                // 8. Save progress immediately
                saveProgress();

            } catch (err) {
                console.error("Error loading chapter:", err);
            }
        }

        function updateNavUI(prevIdx, nextIdx) {
            // Update section counter
            const gotoInput = document.getElementById('goto-section-input');
            gotoInput.value = chapterIndex + 1;

            // Update section info text in bottom nav
            const bottomInfo = document.querySelector('.chapter-nav span[style]');
            if (bottomInfo) {
                bottomInfo.textContent = `Section ${chapterIndex + 1} of ${totalChapters}`;
            }

            // Update header prev/next buttons
            const headerControls = document.querySelector('.header-controls');
            const prevBtn = headerControls.querySelector('.nav-prev');
            const nextBtn = headerControls.querySelector('.nav-next');

            if (prevBtn) {
                if (prevIdx !== null && prevIdx !== undefined) {
                    prevBtn.style.opacity = '';
                    prevBtn.style.cursor = 'pointer';
                    prevBtn.style.pointerEvents = '';
                    prevBtn.onclick = (e) => { e.preventDefault(); loadChapter(prevIdx); };
                } else {
                    prevBtn.style.opacity = '0.3';
                    prevBtn.style.cursor = 'default';
                    prevBtn.style.pointerEvents = 'none';
                    prevBtn.onclick = null;
                }
            }

            if (nextBtn) {
                if (nextIdx !== null && nextIdx !== undefined) {
                    nextBtn.style.opacity = '';
                    nextBtn.style.cursor = '';
                    nextBtn.style.pointerEvents = '';
                    nextBtn.onclick = (e) => { e.preventDefault(); loadChapter(nextIdx); };
                } else {
                    nextBtn.style.opacity = '0.3';
                    nextBtn.style.cursor = 'default';
                    nextBtn.style.pointerEvents = 'none';
                    nextBtn.onclick = null;
                }
            }

            // Update bottom prev/next buttons
            const bottomNav = document.querySelector('.chapter-nav');
            if (bottomNav) {
                const bottomPrev = bottomNav.querySelector('.nav-prev-bottom');
                const bottomNext = bottomNav.querySelector('.nav-next-bottom');

                if (bottomPrev) {
                    if (prevIdx !== null && prevIdx !== undefined) {
                        bottomPrev.className = 'nav-btn nav-prev-bottom';
                        bottomPrev.onclick = (e) => { e.preventDefault(); loadChapter(prevIdx); };
                    } else {
                        bottomPrev.className = 'nav-btn nav-prev-bottom disabled';
                        bottomPrev.onclick = null;
                    }
                }

                if (bottomNext) {
                    if (nextIdx !== null && nextIdx !== undefined) {
                        bottomNext.className = 'nav-btn nav-next-bottom';
                        bottomNext.onclick = (e) => { e.preventDefault(); loadChapter(nextIdx); };
                    } else {
                        bottomNext.className = 'nav-btn nav-next-bottom disabled';
                        bottomNext.onclick = null;
                    }
                }
            }
        }

        function updateTocHighlight(currentHref) {
            // Remove all active classes
            document.querySelectorAll('a.toc-link.active').forEach(el => {
                el.classList.remove('active');
            });
            // Find and activate matching link
            document.querySelectorAll('a.toc-link').forEach(el => {
                const onclick = el.getAttribute('onclick');
                if (onclick && onclick.includes(currentHref)) {
                    el.classList.add('active');
                }
            });
        }

        // --- Browser back/forward support ---
        window.addEventListener('popstate', function (e) {
            if (e.state && e.state.chapterIndex !== undefined) {
                // Use loadChapterNoHistory to avoid pushing duplicate state
                loadChapterNoHistory(e.state.chapterIndex);
            }
        });

        async function loadChapterNoHistory(idx) {
            if (idx < 0 || idx >= totalChapters) return;
            try {
                const resp = await fetch(`/api/chapter/${bookId}/${idx}`);
                if (!resp.ok) return;
                const data = await resp.json();

                bookContentDiv.innerHTML = data.content;
                chapterIndex = data.chapter_index;
                updateNavUI(data.prev_idx, data.next_idx);
                updateTocHighlight(data.href);
                contentScroll.scrollTop = 0;
                applyZoom();
                saveProgress();
            } catch (err) {
                console.error("Error loading chapter:", err);
            }
        }

        // Set initial history state
        history.replaceState({ chapterIndex: chapterIndex }, '');

        function findAndGo(filename) {
            // cleanup anchor
            let cleanFile = filename.split('#')[0];
            // Decode URI just in case (e.g. spaces -> %20)
            try { cleanFile = decodeURIComponent(cleanFile); } catch (e) { }

            let idx = spineMap[cleanFile];

            // Robust Fallback: try matching basename if full path fails
            if (idx === undefined) {
                const basename = cleanFile.split('/').pop();
                for (const key in spineMap) {
                    if (key.endsWith(basename)) {
                        idx = spineMap[key];
                        break;
                    }
                }
            }

            if (idx !== undefined) {
                // Extract anchor from original filename
                const anchor = filename.includes('#') ? filename.split('#')[1] : '';
                loadChapter(idx, anchor);
            } else {
                console.error("Could not find index for", filename);
                // Don't alert for same-page anchors
                if (filename.startsWith('#')) {
                    window.location.hash = filename;
                } else {
                    console.warn("Could not find chapter: " + filename);
                }
            }
        }

        // --- Intercept internal content links ---
        // Use event delegation on content-scroll so it works after content swap
        document.getElementById('content-scroll').addEventListener('click', function (e) {
            const link = e.target.closest('a');
            if (!link) return;

            // Only intercept links inside book content, not nav buttons
            if (!document.getElementById('book-content-div').contains(link)) return;

            const href = link.getAttribute('href');
            if (!href) return;

            // Skip external links
            if (/^[a-z]+:\/\//i.test(href) || href.startsWith('mailto:')) return;

            // Internal link ‚Äî intercept it
            e.preventDefault();
            findAndGo(href);
        });

        // --- Text Selection Hook for Chat ---
        document.addEventListener('selectionchange', () => {
            const selection = window.getSelection();
            const text = selection.toString().trim();

            if (text && text.length > 0) {
                const contentDiv = document.getElementById('book-content-div');
                if (contentDiv && contentDiv.contains(selection.anchorNode)) {
                    if (window.updateChatContext) {
                        window.updateChatContext(text);
                    }
                }
            }
        });

        // --- Go To Section Logic ---
        const gotoInput = document.getElementById('goto-section-input');
        const gotoBtn = document.getElementById('goto-btn');

        function handleGoTo() {
            const val = parseInt(gotoInput.value);
            if (val && val >= 1 && val <= totalChapters) {
                loadChapter(val - 1);
            } else {
                alert("Invalid section number");
            }
        }

        gotoBtn.addEventListener('click', handleGoTo);
        gotoInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleGoTo();
        });

    </script>
</body>

</html>