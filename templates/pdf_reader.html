<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <!-- PDF.js Styles -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">

    <style>
        :root {
            --header-height: 50px;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* Header */
        header {
            height: var(--header-height);
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid #444;
            flex-shrink: 0;
            justify-content: space-between;
            z-index: 10;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .nav-home {
            color: #ccc;
            text-decoration: none;
            font-size: 0.9em;
        }

        .nav-home:hover {
            color: white;
        }

        .book-title {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 400px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn-icon {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
            border-radius: 4px;
        }

        .btn-icon:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .page-info {
            font-size: 0.9em;
            color: #ccc;
            min-width: 80px;
            text-align: center;
        }

        /* Main Container: Split Pane */
        #main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - var(--header-height));
            overflow: hidden;
        }

        /* PDF Viewer Area */
        #pdf-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #525659;
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease;
        }

        #pdf-scroll-container {
            flex: 1;
            overflow: auto;
            position: relative;
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        #pdf-content {
            position: relative;
            display: flex;
            gap: 10px;
            /* Anchor for absolute children */
        }

        .page-container {
            position: relative;
        }

        /* The canvas where PDF is drawn */
        canvas {
            display: block;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Text Layer for Selection */
        .textLayer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
            /* CRITICAL FIX: Ensure transform origin is top-left so scale matches canvas */
            transform-origin: 0 0;
        }

        /* PDF ToC Sidebar */
        #toc-sidebar {
            width: 250px;
            background: #f8f9fa;
            border-right: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
            padding: 10px;
        }

        .toc-item {
            padding: 4px 8px;
            cursor: pointer;
            color: #333;
            font-size: 0.9em;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .toc-item:hover {
            background: #e9ecef;
            color: #000;
        }

        .toc-depth-1 {
            padding-left: 10px;
        }

        .toc-depth-2 {
            padding-left: 20px;
        }

        .toc-depth-3 {
            padding-left: 30px;
        }

        .nav-header {
            font-weight: bold;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <header>
        <div class="header-left">
            <a href="/" class="nav-home">‚Üê Back</a>
            <span class="book-title" title="{{ book.metadata.title }}">{{ book.metadata.title }}</span>
        </div>

        <!-- Toolbar -->
        <div class="header-controls">
            <button class="btn-icon" id="prev-page" title="Previous Page">‚óÄ</button>
            <span class="page-info">
                Page
                <input type="number" id="page-num-input" value="--"
                    style="width: 50px; text-align: center; background: #34495e; color: white; border: 1px solid #555; border-radius: 4px; padding: 2px;">
                / <span id="page-count">--</span>
            </span>
            <button class="btn-icon" id="next-page" title="Next Page">‚ñ∂</button>
            <span style="border-left: 1px solid #555; height: 20px; margin: 0 5px;"></span>
            <button class="btn-icon" id="zoom-out" title="Zoom Out">‚àí</button>
            <button class="btn-icon" id="zoom-in" title="Zoom In">+</button>
            <span style="border-left: 1px solid #555; height: 20px; margin: 0 5px;"></span>
            <button class="btn-icon" id="fit-width" title="Fit Width" style="font-size: 0.8em;">‚Üî Width</button>
            <button class="btn-icon" id="fit-page" title="Fit Page" style="font-size: 0.8em;">‚Üï Page</button>
            <button class="btn-icon" id="toggle-toc" title="Table of Contents" style="font-size: 0.8em;">üìë ToC</button>
            <button class="btn-icon" id="toggle-dual" title="Dual Page View" style="font-size: 0.8em;">üìñ Dual</button>
        </div>

        <div style="display: flex; gap: 10px;">
            <button id="toggle-chat-btn" class="btn-icon" title="Toggle Chat"
                style="font-size: 0.9em; border: 1px solid #555;" onclick="window.RightSidebar.toggle()">üí¨
                Chat</button>
        </div>
    </header>

    <div id="main-container">
        <!-- PDF ToC Sidebar -->
        <div id="toc-sidebar" style="display:none;">
            <div class="nav-header">Table of Contents</div>
            <div id="toc-list"></div>
        </div>

        <!-- PDF Viewer -->
        <div id="pdf-wrapper">
            <div id="pdf-scroll-container">
                <div id="pdf-content">
                    <div class="page-container" id="page-container-1">
                        <canvas id="the-canvas"></canvas>
                        <div id="text-layer" class="textLayer"></div>
                        <div class="highlight-layer" id="highlight-layer-1"></div>
                    </div>
                    <div class="page-container" id="page-container-2" style="display:none;">
                        <canvas id="the-canvas-2"></canvas>
                        <div id="text-layer-2" class="textLayer"></div>
                        <div class="highlight-layer" id="highlight-layer-2"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Set bookId before chat component so loadChatHistory can use it -->
        <!-- Set bookId before chat component so loadChatHistory can use it -->
        <!-- Data Injection: Prevent formatter errors -->
        <script type="application/json" id="pdf-data">
        {
            "bookId": "{{ book_id }}",
            "bookTitle": "{{ book.metadata.title | replace('"', '\\"') }}",
            "bookAuthor": "{{ book.metadata.authors | join(', ') | replace('"', '\\"') }}",
            "pdfUrl": "{{ pdf_url }}",
            "initialPage": {{ initial_page }},
            "initialZoom": {{ initial_zoom }},
            "initialDualPage": {{ initial_dual_page }}
        }
        </script>
        <script>
            try {
                window.pdfData = JSON.parse(document.getElementById('pdf-data').textContent);
                window.bookId = window.pdfData.bookId;
            } catch (e) {
                console.error("Failed to parse PDF data", e);
            }
        </script>

        <!-- Chat Sidebar Included Here - REPLACED with Unified Sidebar -->
        {% include "components/right_sidebar.html" %}
    </div>

    <!-- Selection Menu (Popover) -->
    <div id="selection-menu"
        style="display:none; position:absolute; z-index:100; background:#333; color:white; padding:5px; border-radius:4px;">
        <button onclick="triggerAnnotation('highlight')">Highlight</button>
        <button onclick="triggerAskAI()">Ask AI</button>
    </div>

    <style>
        #selection-menu button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 0.9em;
        }

        #selection-menu button:hover {
            background: #555;
            border-radius: 3px;
        }

        /* Same size as canvas (set in JS); same coordinate system as selection (canvas.getBoundingClientRect) */
        .highlight-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            box-sizing: border-box;
        }

        .highlight-layer .highlight-rect {
            pointer-events: auto;
        }

        /* PDF Highlight Overlay */
        .highlight-rect {
            position: absolute;
            background-color: rgba(255, 235, 59, 0.72);
            cursor: pointer;
            z-index: 5;
            border-bottom: 2px solid transparent;
        }

        .highlight-rect:hover {
            border-bottom-color: #f39c12;
            background-color: rgba(255, 235, 59, 0.85);
        }

        .highlight-rect.has-note {
            border-bottom: 2px solid #e74c3c;
            background-color: rgba(255, 193, 7, 0.7);
        }

        .highlight-rect.active {
            box-shadow: 0 0 0 3px #3498db;
            background-color: rgba(52, 152, 219, 0.5);
            z-index: 10;
        }
    </style>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const config = window.pdfData || {};
        const url = config.pdfUrl + "?v=" + new Date().getTime();
        const bookId = config.bookId;
        // window.bookId is already set

        // Restore State
        let pageNum = config.initialPage;
        let scale = config.initialZoom;
        let dualPageMode = config.initialDualPage;

        let pdfDoc = null,
            pageRendering = false,
            pageNumPending = null,
            canvas = document.getElementById('the-canvas'),
            ctx = canvas.getContext('2d'),
            textLayerDiv = document.getElementById('text-layer'),
            canvas2 = document.getElementById('the-canvas-2'),
            ctx2 = canvas2.getContext('2d'),
            textLayerDiv2 = document.getElementById('text-layer-2'),
            pageContainer2 = document.getElementById('page-container-2');

        // Update dual button text on load
        function updateDualButtonText() {
            const btn = document.getElementById('toggle-dual');
            btn.textContent = dualPageMode ? 'üìñ Single' : 'üìñ Dual';
            btn.title = dualPageMode ? 'Switch to Single Page' : 'Switch to Dual Page';
        }
        updateDualButtonText();

        // --- Save Progress ---
        let saveTimeout;
        function saveProgress() {
            const data = {
                chapter_index: 0,
                page_num: pageNum,
                scroll_position: 0,
                zoom: scale,
                dual_page: dualPageMode
            };

            fetch(`/api/progress/${bookId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            }).catch(console.error);
        }

        function debounceSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveProgress, 1000);
        }

        // --- PDF Rendering ---

        function renderSinglePage(pageObj, targetCanvas, targetCtx, targetTextLayer) {
            const viewport = pageObj.getViewport({ scale: scale });
            const dpr = window.devicePixelRatio || 1;

            targetCanvas.width = Math.floor(viewport.width * dpr);
            targetCanvas.height = Math.floor(viewport.height * dpr);
            targetCanvas.style.width = Math.floor(viewport.width) + 'px';
            targetCanvas.style.height = Math.floor(viewport.height) + 'px';

            targetTextLayer.style.height = Math.floor(viewport.height) + 'px';
            targetTextLayer.style.width = Math.floor(viewport.width) + 'px';
            targetTextLayer.style.setProperty('--scale-factor', scale);

            const highlightLayer = targetTextLayer.parentElement && targetTextLayer.parentElement.querySelector('.highlight-layer');
            if (highlightLayer) {
                highlightLayer.style.width = Math.floor(viewport.width) + 'px';
                highlightLayer.style.height = Math.floor(viewport.height) + 'px';
            }

            targetCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

            const renderContext = {
                canvasContext: targetCtx,
                viewport: viewport
            };
            return pageObj.render(renderContext).promise.then(function () {
                return pageObj.getTextContent();
            }).then(function (textContent) {
                targetTextLayer.innerHTML = '';
                const task = pdfjsLib.renderTextLayer({
                    textContentSource: textContent,
                    container: targetTextLayer,
                    viewport: viewport,
                    textDivs: []
                });
                return task.promise;
            });
        }

        function renderPage(num) {
            pageRendering = true;

            if (dualPageMode) {
                pageContainer2.style.display = 'block';
                const leftPageNum = num;
                const rightPageNum = num + 1;

                // Render left page
                const leftPromise = pdfDoc.getPage(leftPageNum).then(function (page) {
                    return renderSinglePage(page, canvas, ctx, textLayerDiv);
                });

                // Render right page if it exists
                let rightPromise;
                if (rightPageNum <= pdfDoc.numPages) {
                    rightPromise = pdfDoc.getPage(rightPageNum).then(function (page) {
                        return renderSinglePage(page, canvas2, ctx2, textLayerDiv2);
                    });
                } else {
                    // No right page ‚Äî clear canvas 2
                    rightPromise = Promise.resolve();
                    canvas2.width = 0;
                    canvas2.height = 0;
                    canvas2.style.width = '0px';
                    canvas2.style.height = '0px';
                    textLayerDiv2.innerHTML = '';
                }

                Promise.all([leftPromise, rightPromise]).then(function () {
                    pageRendering = false;
                    requestAnimationFrame(function () {
                        renderHighlights();
                        renderSidebarList();
                    });
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });

                // Update page display
                if (rightPageNum <= pdfDoc.numPages) {
                    document.getElementById('page-num-input').value = leftPageNum + '-' + rightPageNum;
                } else {
                    document.getElementById('page-num-input').value = leftPageNum;
                }
            } else {
                // Single page mode
                pageContainer2.style.display = 'none';

                pdfDoc.getPage(num).then(function (page) {
                    return renderSinglePage(page, canvas, ctx, textLayerDiv);
                }).then(function () {
                    pageRendering = false;
                    requestAnimationFrame(function () {
                        renderHighlights();
                        renderSidebarList();
                    });
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });

                document.getElementById('page-num-input').value = num;
            }

            debounceSave();
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function onPrevPage() {
            const step = dualPageMode ? 2 : 1;
            if (pageNum <= 1) return;
            pageNum = Math.max(1, pageNum - step);
            queueRenderPage(pageNum);
        }
        function onNextPage() {
            const step = dualPageMode ? 2 : 1;
            if (pageNum >= pdfDoc.numPages) return;
            pageNum = Math.min(pdfDoc.numPages, pageNum + step);
            queueRenderPage(pageNum);
        }
        function onZoomIn() { scale += 0.2; renderPage(pageNum); }
        function onZoomOut() { if (scale > 0.4) scale -= 0.2; renderPage(pageNum); }

        function onFitWidth() {
            pdfDoc.getPage(pageNum).then(function (page) {
                const baseViewport = page.getViewport({ scale: 1.0 });
                const container = document.getElementById('pdf-scroll-container');
                const availableWidth = container.clientWidth - 40; // subtract padding
                if (dualPageMode) {
                    // Two pages side-by-side plus gap
                    scale = (availableWidth - 10) / (baseViewport.width * 2);
                } else {
                    scale = availableWidth / baseViewport.width;
                }
                renderPage(pageNum);
            });
        }

        function onFitPage() {
            pdfDoc.getPage(pageNum).then(function (page) {
                const baseViewport = page.getViewport({ scale: 1.0 });
                const container = document.getElementById('pdf-scroll-container');
                const availableWidth = container.clientWidth - 40;
                const availableHeight = container.clientHeight - 40;
                let scaleW, scaleH;
                if (dualPageMode) {
                    scaleW = (availableWidth - 10) / (baseViewport.width * 2);
                } else {
                    scaleW = availableWidth / baseViewport.width;
                }
                scaleH = availableHeight / baseViewport.height;
                scale = Math.min(scaleW, scaleH);
                renderPage(pageNum);
            });
        }

        function onToggleDual() {
            dualPageMode = !dualPageMode;
            updateDualButtonText();
            // Ensure pageNum is odd in dual mode for proper spread alignment
            if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                pageNum = pageNum - 1;
            }
            renderPage(pageNum);
            debounceSave();
        }

        function onToggleToc() {
            const tocSidebar = document.getElementById('toc-sidebar');
            if (tocSidebar.style.display === 'none') {
                tocSidebar.style.display = 'flex';
                // Populate ToC from PDF outline if not already done
                if (!tocSidebar.dataset.loaded) {
                    pdfDoc.getOutline().then(function (outline) {
                        const tocList = document.getElementById('toc-list');
                        tocList.innerHTML = '';
                        if (outline && outline.length > 0) {
                            renderOutline(outline, tocList, 1);
                        } else {
                            tocList.innerHTML = '<div style="color:#999; padding:10px;">No table of contents available in this PDF.</div>';
                        }
                        tocSidebar.dataset.loaded = 'true';
                    });
                }
            } else {
                tocSidebar.style.display = 'none';
            }
        }

        function renderOutline(items, container, depth) {
            items.forEach(function (item) {
                const div = document.createElement('div');
                div.className = 'toc-item toc-depth-' + Math.min(depth, 3);
                div.textContent = item.title;
                div.addEventListener('click', function () {
                    // Navigate to the destination
                    if (item.dest) {
                        // dest can be a string (named destination) or an array (explicit destination)
                        const destPromise = typeof item.dest === 'string'
                            ? pdfDoc.getDestination(item.dest)
                            : Promise.resolve(item.dest);
                        destPromise.then(function (dest) {
                            if (dest) {
                                pdfDoc.getPageIndex(dest[0]).then(function (pageIndex) {
                                    pageNum = pageIndex + 1;
                                    // In dual mode, snap to odd page
                                    if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                                        pageNum = pageNum - 1;
                                    }
                                    queueRenderPage(pageNum);
                                });
                            }
                        });
                    } else if (item.url) {
                        window.open(item.url, '_blank');
                    }
                });
                container.appendChild(div);
                if (item.items && item.items.length > 0) {
                    renderOutline(item.items, container, depth + 1);
                }
            });
        }

        document.getElementById('prev-page').addEventListener('click', onPrevPage);
        document.getElementById('next-page').addEventListener('click', onNextPage);
        document.getElementById('zoom-in').addEventListener('click', () => { onZoomIn(); debounceSave(); });
        document.getElementById('zoom-out').addEventListener('click', () => { onZoomOut(); debounceSave(); });
        document.getElementById('fit-width').addEventListener('click', () => { onFitWidth(); debounceSave(); });
        document.getElementById('fit-page').addEventListener('click', () => { onFitPage(); debounceSave(); });
        document.getElementById('toggle-toc').addEventListener('click', onToggleToc);
        document.getElementById('toggle-dual').addEventListener('click', onToggleDual);

        // Go to Page Input
        const pageInput = document.getElementById('page-num-input');
        pageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                // Handle both single page "5" and dual range "5-6" inputs
                const rawVal = pageInput.value.split('-')[0].trim();
                const val = parseInt(rawVal);
                if (val && val >= 1 && val <= pdfDoc.numPages) {
                    pageNum = val;
                    if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                        pageNum = pageNum - 1;
                    }
                    queueRenderPage(pageNum);
                } else {
                    // Reset to current
                    pageInput.value = pageNum;
                }
            }
        });

        // Load Document
        pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
            pdfDoc = pdfDoc_;
            document.getElementById('page-count').textContent = pdfDoc.numPages;
            // In dual mode, snap to odd page on initial load
            if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                pageNum = pageNum - 1;
            }
            renderPage(pageNum);
        });

        // --- Keyboard Navigation ---
        // --- Keyboard Navigation ---
        const pdfWrapper = document.getElementById('pdf-wrapper');
        // Make wrapper focusable
        pdfWrapper.setAttribute('tabindex', '0');
        // Focus on load so keys work immediately
        pdfWrapper.focus();

        // Re-focus wrapper when clicking on canvas/text layer
        document.getElementById('pdf-content').addEventListener('click', () => {
            pdfWrapper.focus();
        });

        pdfWrapper.addEventListener('keydown', (e) => {
            // Ignore if focus is somehow on an input (though event is scoped to wrapper, 
            // bubbles from children could trigger this if we had inputs inside, which we don't currently)

            if (e.key === 'ArrowLeft') {
                e.preventDefault(); // Prevent horizontal scrolling if any
                onPrevPage();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                onNextPage();
            }
            // Up/Down arrows will bubble/default to scrolling the container naturally
        });

        // --- Text Selection & Context - Override/Hook ---

        // --- Text Selection & Context - Override/Hook ---
        // Replacing legacy hook with Annotation System

        const selectionMenu = document.getElementById('selection-menu');

        let currentSelectionRect = null; // Stored as { pageNum, x, y, w, h } (normalized 0-1)
        let currentSelectionQuote = "";

        document.addEventListener('mouseup', (e) => {
            const selection = window.getSelection();
            if (selection.toString().trim().length > 0) {
                // Check if inside a page container
                const pageContainer = selection.anchorNode.parentElement.closest('.page-container');
                if (pageContainer) {
                    // Which page?
                    const containerId = pageContainer.id; // page-container-1 or -2
                    // Map container to actual PDF page number
                    let targetPageNum;
                    if (containerId === 'page-container-1') {
                        targetPageNum = dualPageMode ? pageNum : pageNum; // left page is always 'pageNum' in logic
                    } else {
                        targetPageNum = pageNum + 1;
                    }

                    // Normalize rects relative to the CANVAS / Container
                    const range = selection.getRangeAt(0);
                    const clientRects = range.getClientRects();
                    const pageContainerRect = pageContainer.getBoundingClientRect();

                    // Canvas is the reference for coordinate normalization (0-1)
                    const canvasEl = pageContainer.querySelector('canvas');
                    const refRect = canvasEl ? canvasEl.getBoundingClientRect() : pageContainerRect;
                    const refW = refRect.width || 1;
                    const refH = refRect.height || 1;

                    let rectsList = [];

                    for (let i = 0; i < clientRects.length; i++) {
                        const r = clientRects[i];
                        // Calculate relative coordinates
                        const x = (r.left - refRect.left) / refW;
                        const y = (r.top - refRect.top) / refH;
                        const w = r.width / refW;
                        const h = r.height / refH;

                        // Filter out tiny/invalid rects
                        if (w > 0.001 && h > 0.001) {
                            rectsList.push([
                                Math.max(0, Math.min(1, x)),
                                Math.max(0, Math.min(1, y)),
                                Math.max(0, Math.min(1, w)),
                                Math.max(0, Math.min(1, h))
                            ]);
                        }
                    }

                    if (rectsList.length > 0) {
                        // Position menu based on the first rect or the bounding rect of the range
                        const boundRect = range.getBoundingClientRect();
                        selectionMenu.style.display = 'flex';
                        selectionMenu.style.top = (window.scrollY + boundRect.top - 40) + 'px';
                        selectionMenu.style.left = (window.scrollX + boundRect.left + boundRect.width / 2 - 75) + 'px';

                        currentSelectionRect = {
                            page_num: targetPageNum,
                            // Fallback single rect for legacy or logic that expects it (first rect or bounding)
                            x: rectsList[0][0],
                            y: rectsList[0][1],
                            w: rectsList[0][2],
                            h: rectsList[0][3],
                            // IMPORTANT: Store the full list of rects
                            rects: rectsList
                        };
                        currentSelectionQuote = selection.toString().trim();
                        return;
                    }
                }
            }
            if (!selectionMenu.contains(e.target)) {
                selectionMenu.style.display = 'none';
            }
        });


        async function triggerAnnotation(type) {
            if (!currentSelectionRect) return;

            selectionMenu.style.display = 'none';

            const payload = {
                type: (type === 'ask') ? 'chat_thread' : type,
                target: {
                    chapter_index: 0, // PDF treats whole file as chap 0 for now
                    page_num: currentSelectionRect.page_num,
                    rect: [currentSelectionRect.x, currentSelectionRect.y, currentSelectionRect.w, currentSelectionRect.h],
                    rects: currentSelectionRect.rects, // Send the list of rects
                    quote: currentSelectionQuote
                },
                content: {
                    text: (type === 'note') ? "New Note" : "",
                    color: "yellow"
                }
            };

            try {
                const resp = await fetch(`/api/annotations/${bookId}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await resp.json();

                await loadAnnotations();

                if (type === 'note') {
                    window.RightSidebar.openThread(data.id);
                } else if (type === 'ask') {
                    window.RightSidebar.openThread(data.id, "Explain this context: " + currentSelectionQuote);
                }
            } catch (e) {
                console.error(e);
            }
        }

        function triggerAskAI() {
            const selectionMenu = document.getElementById('selection-menu');
            selectionMenu.style.display = 'none';
            if (currentSelectionQuote) {
                if (window.RightSidebar && window.RightSidebar.openGlobalChat) {
                    window.RightSidebar.openGlobalChat(currentSelectionQuote);
                }
            }
        }


        // --- PDF Rendering Logic ---
        let currentAnnotations = [];

        async function loadAnnotations() {
            try {
                const resp = await fetch(`/api/annotations/${bookId}`);
                currentAnnotations = await resp.json();
                renderHighlights(); // Re-render on page
                renderSidebarList(); // Update sidebar list
            } catch (e) { console.error(e); }
        }

        // Use global variable for annotations to allow re-rendering on page turn/zoom
        // Call this whenever renderPage() finishes
        // Highlight Activation: navigate to page if needed, then highlight and scroll
        window.activateHighlight = function (annId) {
            document.querySelectorAll('.highlight-rect.active').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.annotation-item.active').forEach(el => el.classList.remove('active'));

            const ann = currentAnnotations.find(a => a.id === annId);
            const annPage = ann && ann.target && ann.target.page_num != null ? ann.target.page_num : null;

            function doActivate() {
                const target = document.querySelector(`.highlight-rect[data-id="${annId}"]`);
                if (target) {
                    target.classList.add('active');
                    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                const item = document.querySelector(`.annotation-item[data-id="${annId}"]`);
                if (item) {
                    item.classList.add('active');
                    item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            if (annPage != null && annPage !== pageNum && (!dualPageMode || Math.abs(annPage - pageNum) > 1)) {
                pageNum = dualPageMode && (annPage % 2 === 0) ? annPage - 1 : annPage;
                if (dualPageMode && pageNum < 1) pageNum = 1;
                queueRenderPage(pageNum);
                setTimeout(function () {
                    renderHighlights();
                    doActivate();
                }, 350);
            } else {
                doActivate();
            }
        }
        function renderHighlights() {
            // Clear existing highlights
            document.querySelectorAll('.highlight-rect').forEach(el => el.remove());

            // Get currently visible pages
            const pagesToShow = [pageNum];
            if (dualPageMode && (pageNum + 1 <= pdfDoc.numPages)) {
                pagesToShow.push(pageNum + 1);
            }

            currentAnnotations.forEach(ann => {
                const rects = ann.target.rects || (ann.target.rect ? [ann.target.rect] : []);
                if (rects.length === 0) return;

                const annPage = ann.target.page_num;

                // Is this annotation on a visible page?
                if (pagesToShow.includes(annPage)) {
                    // Determine which container to draw in
                    let container;
                    if (dualPageMode) {
                        if (annPage === pageNum) container = document.getElementById('page-container-1');
                        else container = document.getElementById('page-container-2');
                    } else {
                        container = document.getElementById('page-container-1');
                    }

                    if (container) {
                        // Use dedicated highlight-layer (sibling of canvas/textLayer); coords match selection container
                        const layer = container.querySelector('.highlight-layer') || container;

                        rects.forEach(r => {
                            const div = document.createElement('div');
                            div.className = 'highlight-rect';
                            if (ann.type !== 'highlight') div.classList.add('has-note');

                            // Style as Pink Underline
                            // Remove background, use border-bottom
                            div.style.background = 'transparent';
                            div.style.borderBottom = '2px solid #ff69b4'; // HotPink

                            div.style.left = (r[0] * 100) + '%';
                            div.style.top = (r[1] * 100) + '%';
                            div.style.width = (r[2] * 100) + '%';
                            // Adjust height to raise the underline (0.65 ratio as requested)
                            div.style.height = (r[3] * 100 * 0.65) + '%';

                            div.dataset.id = ann.id;

                            div.onclick = (e) => {
                                e.stopPropagation();
                                window.RightSidebar.openThread(ann.id);
                            };

                            layer.appendChild(div);
                        });
                    }
                }
            });
        }


        function renderSidebarList() {
            const listContainer = document.getElementById('annotations-list-container');
            if (!listContainer) return;

            const visiblePages = [pageNum];
            if (dualPageMode && (pageNum + 1 <= pdfDoc.numPages)) visiblePages.push(pageNum + 1);
            const visibleAnns = currentAnnotations.filter(a => (a.target && a.target.page_num != null) && visiblePages.includes(a.target.page_num));

            if (visibleAnns.length === 0) {
                listContainer.innerHTML = '<div style="padding:20px; color:#999; text-align:center;">No annotations on this page.</div>';
                return;
            }

            listContainer.innerHTML = visibleAnns.map(a => {
                return `
                <div class="annotation-item" onclick="window.activateHighlight('${a.id}')" data-id="${a.id}">
                    <div class="annotation-quote">Page ${(a.target && a.target.page_num) != null ? a.target.page_num : '?'}: "${(a.target && a.target.quote ? a.target.quote : "").substring(0, 40)}..."</div>
                    <div class="annotation-note-preview">
                        ${a.content && a.content.text ? marked.parse(a.content.text) : '<span style="color:#ccc;font-style:italic;">No note</span>'}
                    </div>
                    <div class="annotation-meta" style="margin-top:5px; align-items:center;">
                        <span>${a.type}</span>
                        <div class="actions">
                            <button class="ann-edit-btn" data-id="${a.id}" title="Edit">‚úèÔ∏è</button>
                            <button class="ann-delete-btn" data-id="${a.id}" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                </div>
            `}).join('');

            listContainer.querySelectorAll('.ann-edit-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const ann = currentAnnotations.find(x => x.id === btn.dataset.id);
                    window.RightSidebar.startEdit(btn.dataset.id, ann && ann.content ? (ann.content.text || '') : '');
                });
            });
            listContainer.querySelectorAll('.ann-delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => { e.stopPropagation(); window.RightSidebar.deleteAnnotation(btn.dataset.id); });
            });
        }

        async function updateAnnotationContent(id, newText) {
            try {
                const resp = await fetch(`/api/annotations/${bookId}`);
                const all = await resp.json();
                const target = all.find(a => a.id === id);
                if (!target) return;
                target.content = target.content || {};
                target.content.text = newText;
                await fetch(`/api/annotations/${bookId}/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(target)
                });
                await loadAnnotations();
            } catch (e) { console.error(e); }
        }
        window.updateAnnotationContent = updateAnnotationContent;
        window.reloadAnnotations = loadAnnotations;

        window.loadAnnotationsList = renderSidebarList;
        window.loadAnnotationThread = async (annId) => {
            // Logic identical to EPUB reader... duplicate code T_T
            // Ideally we'd move this to rightsbar.js or similar
            const ann = currentAnnotations.find(a => a.id === annId);
            if (!ann) return;
            document.getElementById('thread-title').textContent = ann.type === 'chat_thread' ? 'Discussion' : 'Note';
            document.getElementById('thread-placeholder').style.display = 'none';
            const noteDisplay = document.getElementById('thread-note-display');
            if (ann.content.text) {
                noteDisplay.style.display = 'block';
                noteDisplay.innerHTML = marked.parse(ann.content.text);
            } else {
                noteDisplay.style.display = 'none';
            }
        };

        // Hook into rendering loop
        const originalRenderPage = renderPage;
        renderPage = function (num) {
            // Call original (async logic inside, but we can't await it easily without refactor)
            // But renderPage uses promises internally.

            // We need to inject our renderHighlights AFTER the page is drawn.
            // renderPage returns nothing, but it chains promises on 'pdfDoc.getPage'
            // Let's just create a wrapper that waits a bit or hooks into the promise chain if possible.
            // Actually, renderPage calls debounceSave(). We can hook into that?
            // Better: modify renderPage to fire an event.
            // Or just append our logic to the end of the promise chain in renderPage?
            // Since we can't easily modify the function *inside* the closure without full replace,
            // let's rely on the fact that we completely replaced the script block in previous steps?
            // No, we are editing existing script.

            // The previous 'renderPage' function is still in the file. 
            // We are appending this code *after* it. 
            // So we can overwrite `renderPage`.

            // Let's overwrite renderPage completely if possible? 
            // No, that's huge. 

            // Hack: Use a mutation observer on textLayer? 
            // When textLayer is populated, render highlights.

            originalRenderPage(num);
        };

        // Initial load
        loadAnnotations();
    </script>
</body>

</html>