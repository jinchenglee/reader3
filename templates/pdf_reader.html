<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <!-- PDF.js Styles -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">

    <style>
        :root {
            --header-height: 50px;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* Header */
        header {
            height: var(--header-height);
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid #444;
            flex-shrink: 0;
            justify-content: space-between;
            z-index: 10;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .nav-home {
            color: #ccc;
            text-decoration: none;
            font-size: 0.9em;
        }

        .nav-home:hover {
            color: white;
        }

        .book-title {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 400px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn-icon {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
            border-radius: 4px;
        }

        .btn-icon:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .page-info {
            font-size: 0.9em;
            color: #ccc;
            min-width: 80px;
            text-align: center;
        }

        /* Main Container: Split Pane */
        #main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - var(--header-height));
            overflow: hidden;
        }

        /* PDF Viewer Area */
        #pdf-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #525659;
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease;
        }

        #pdf-scroll-container {
            flex: 1;
            overflow: auto;
            position: relative;
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        #pdf-content {
            position: relative;
            display: flex;
            gap: 10px;
            /* Anchor for absolute children */
        }

        .page-container {
            position: relative;
        }

        /* The canvas where PDF is drawn */
        canvas {
            display: block;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Text Layer for Selection */
        .textLayer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
            /* CRITICAL FIX: Ensure transform origin is top-left so scale matches canvas */
            transform-origin: 0 0;
        }

        /* PDF ToC Sidebar */
        #toc-sidebar {
            width: 250px;
            background: #f8f9fa;
            border-right: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
            padding: 10px;
        }

        .toc-item {
            padding: 4px 8px;
            cursor: pointer;
            color: #333;
            font-size: 0.9em;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .toc-item:hover {
            background: #e9ecef;
            color: #000;
        }

        .toc-depth-1 {
            padding-left: 10px;
        }

        .toc-depth-2 {
            padding-left: 20px;
        }

        .toc-depth-3 {
            padding-left: 30px;
        }

        .nav-header {
            font-weight: bold;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <header>
        <div class="header-left">
            <a href="/" class="nav-home">‚Üê Back</a>
            <span class="book-title" title="{{ book.metadata.title }}">{{ book.metadata.title }}</span>
        </div>

        <!-- Toolbar -->
        <div class="header-controls">
            <button class="btn-icon" id="prev-page" title="Previous Page">‚óÄ</button>
            <span class="page-info">
                Page
                <input type="number" id="page-num-input" value="--"
                    style="width: 50px; text-align: center; background: #34495e; color: white; border: 1px solid #555; border-radius: 4px; padding: 2px;">
                / <span id="page-count">--</span>
            </span>
            <button class="btn-icon" id="next-page" title="Next Page">‚ñ∂</button>
            <span style="border-left: 1px solid #555; height: 20px; margin: 0 5px;"></span>
            <button class="btn-icon" id="zoom-out" title="Zoom Out">‚àí</button>
            <button class="btn-icon" id="zoom-in" title="Zoom In">+</button>
            <span style="border-left: 1px solid #555; height: 20px; margin: 0 5px;"></span>
            <button class="btn-icon" id="fit-width" title="Fit Width" style="font-size: 0.8em;">‚Üî Width</button>
            <button class="btn-icon" id="fit-page" title="Fit Page" style="font-size: 0.8em;">‚Üï Page</button>
            <button class="btn-icon" id="toggle-toc" title="Table of Contents" style="font-size: 0.8em;">üìë ToC</button>
            <button class="btn-icon" id="toggle-dual" title="Dual Page View" style="font-size: 0.8em;">üìñ Dual</button>
        </div>

        <div style="display: flex; gap: 10px;">
            <button id="toggle-chat-btn" class="btn-icon" title="Toggle Chat"
                style="font-size: 0.9em; border: 1px solid #555;">üí¨ Chat</button>
        </div>
    </header>

    <div id="main-container">
        <!-- PDF ToC Sidebar -->
        <div id="toc-sidebar" style="display:none;">
            <div class="nav-header">Table of Contents</div>
            <div id="toc-list"></div>
        </div>

        <!-- PDF Viewer -->
        <div id="pdf-wrapper">
            <div id="pdf-scroll-container">
                <div id="pdf-content">
                    <div class="page-container" id="page-container-1">
                        <canvas id="the-canvas"></canvas>
                        <div id="text-layer" class="textLayer"></div>
                    </div>
                    <div class="page-container" id="page-container-2" style="display:none;">
                        <canvas id="the-canvas-2"></canvas>
                        <div id="text-layer-2" class="textLayer"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Set bookId before chat component so loadChatHistory can use it -->
        <!-- Set bookId before chat component so loadChatHistory can use it -->
        <!-- Data Injection: Prevent formatter errors -->
        <script type="application/json" id="pdf-data">
        {
            "bookId": "{{ book_id }}",
            "pdfUrl": "{{ pdf_url }}",
            "initialPage": {{ initial_page }},
            "initialZoom": {{ initial_zoom }},
            "initialDualPage": {{ initial_dual_page }}
        }
        </script>
        <script>
            try {
                window.pdfData = JSON.parse(document.getElementById('pdf-data').textContent);
                window.bookId = window.pdfData.bookId;
            } catch (e) {
                console.error("Failed to parse PDF data", e);
            }
        </script>

        <!-- Chat Sidebar Included Here -->
        {% include "components/chat_component.html" %}
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const config = window.pdfData || {};
        const url = config.pdfUrl;
        const bookId = config.bookId;
        // window.bookId is already set

        // Restore State
        let pageNum = config.initialPage;
        let scale = config.initialZoom;
        let dualPageMode = config.initialDualPage;

        let pdfDoc = null,
            pageRendering = false,
            pageNumPending = null,
            canvas = document.getElementById('the-canvas'),
            ctx = canvas.getContext('2d'),
            textLayerDiv = document.getElementById('text-layer'),
            canvas2 = document.getElementById('the-canvas-2'),
            ctx2 = canvas2.getContext('2d'),
            textLayerDiv2 = document.getElementById('text-layer-2'),
            pageContainer2 = document.getElementById('page-container-2');

        // Update dual button text on load
        function updateDualButtonText() {
            const btn = document.getElementById('toggle-dual');
            btn.textContent = dualPageMode ? 'üìñ Single' : 'üìñ Dual';
            btn.title = dualPageMode ? 'Switch to Single Page' : 'Switch to Dual Page';
        }
        updateDualButtonText();

        // --- Save Progress ---
        let saveTimeout;
        function saveProgress() {
            const data = {
                chapter_index: 0,
                page_num: pageNum,
                scroll_position: 0,
                zoom: scale,
                dual_page: dualPageMode
            };

            fetch(`/api/progress/${bookId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            }).catch(console.error);
        }

        function debounceSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveProgress, 1000);
        }

        // --- PDF Rendering ---

        function renderSinglePage(pageObj, targetCanvas, targetCtx, targetTextLayer) {
            const viewport = pageObj.getViewport({ scale: scale });
            const dpr = window.devicePixelRatio || 1;

            targetCanvas.width = Math.floor(viewport.width * dpr);
            targetCanvas.height = Math.floor(viewport.height * dpr);
            targetCanvas.style.width = Math.floor(viewport.width) + 'px';
            targetCanvas.style.height = Math.floor(viewport.height) + 'px';

            targetTextLayer.style.height = Math.floor(viewport.height) + 'px';
            targetTextLayer.style.width = Math.floor(viewport.width) + 'px';
            targetTextLayer.style.setProperty('--scale-factor', scale);

            targetCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

            const renderContext = {
                canvasContext: targetCtx,
                viewport: viewport
            };
            return pageObj.render(renderContext).promise.then(function () {
                return pageObj.getTextContent();
            }).then(function (textContent) {
                targetTextLayer.innerHTML = '';
                pdfjsLib.renderTextLayer({
                    textContentSource: textContent,
                    container: targetTextLayer,
                    viewport: viewport,
                    textDivs: []
                });
            });
        }

        function renderPage(num) {
            pageRendering = true;

            if (dualPageMode) {
                pageContainer2.style.display = 'block';
                const leftPageNum = num;
                const rightPageNum = num + 1;

                // Render left page
                const leftPromise = pdfDoc.getPage(leftPageNum).then(function (page) {
                    return renderSinglePage(page, canvas, ctx, textLayerDiv);
                });

                // Render right page if it exists
                let rightPromise;
                if (rightPageNum <= pdfDoc.numPages) {
                    rightPromise = pdfDoc.getPage(rightPageNum).then(function (page) {
                        return renderSinglePage(page, canvas2, ctx2, textLayerDiv2);
                    });
                } else {
                    // No right page ‚Äî clear canvas 2
                    rightPromise = Promise.resolve();
                    canvas2.width = 0;
                    canvas2.height = 0;
                    canvas2.style.width = '0px';
                    canvas2.style.height = '0px';
                    textLayerDiv2.innerHTML = '';
                }

                Promise.all([leftPromise, rightPromise]).then(function () {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });

                // Update page display
                if (rightPageNum <= pdfDoc.numPages) {
                    document.getElementById('page-num-input').value = leftPageNum + '-' + rightPageNum;
                } else {
                    document.getElementById('page-num-input').value = leftPageNum;
                }
            } else {
                // Single page mode
                pageContainer2.style.display = 'none';

                pdfDoc.getPage(num).then(function (page) {
                    return renderSinglePage(page, canvas, ctx, textLayerDiv);
                }).then(function () {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });

                document.getElementById('page-num-input').value = num;
            }

            debounceSave();
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function onPrevPage() {
            const step = dualPageMode ? 2 : 1;
            if (pageNum <= 1) return;
            pageNum = Math.max(1, pageNum - step);
            queueRenderPage(pageNum);
        }
        function onNextPage() {
            const step = dualPageMode ? 2 : 1;
            if (pageNum >= pdfDoc.numPages) return;
            pageNum = Math.min(pdfDoc.numPages, pageNum + step);
            queueRenderPage(pageNum);
        }
        function onZoomIn() { scale += 0.2; renderPage(pageNum); }
        function onZoomOut() { if (scale > 0.4) scale -= 0.2; renderPage(pageNum); }

        function onFitWidth() {
            pdfDoc.getPage(pageNum).then(function (page) {
                const baseViewport = page.getViewport({ scale: 1.0 });
                const container = document.getElementById('pdf-scroll-container');
                const availableWidth = container.clientWidth - 40; // subtract padding
                if (dualPageMode) {
                    // Two pages side-by-side plus gap
                    scale = (availableWidth - 10) / (baseViewport.width * 2);
                } else {
                    scale = availableWidth / baseViewport.width;
                }
                renderPage(pageNum);
            });
        }

        function onFitPage() {
            pdfDoc.getPage(pageNum).then(function (page) {
                const baseViewport = page.getViewport({ scale: 1.0 });
                const container = document.getElementById('pdf-scroll-container');
                const availableWidth = container.clientWidth - 40;
                const availableHeight = container.clientHeight - 40;
                let scaleW, scaleH;
                if (dualPageMode) {
                    scaleW = (availableWidth - 10) / (baseViewport.width * 2);
                } else {
                    scaleW = availableWidth / baseViewport.width;
                }
                scaleH = availableHeight / baseViewport.height;
                scale = Math.min(scaleW, scaleH);
                renderPage(pageNum);
            });
        }

        function onToggleDual() {
            dualPageMode = !dualPageMode;
            updateDualButtonText();
            // Ensure pageNum is odd in dual mode for proper spread alignment
            if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                pageNum = pageNum - 1;
            }
            renderPage(pageNum);
            debounceSave();
        }

        function onToggleToc() {
            const tocSidebar = document.getElementById('toc-sidebar');
            if (tocSidebar.style.display === 'none') {
                tocSidebar.style.display = 'flex';
                // Populate ToC from PDF outline if not already done
                if (!tocSidebar.dataset.loaded) {
                    pdfDoc.getOutline().then(function (outline) {
                        const tocList = document.getElementById('toc-list');
                        tocList.innerHTML = '';
                        if (outline && outline.length > 0) {
                            renderOutline(outline, tocList, 1);
                        } else {
                            tocList.innerHTML = '<div style="color:#999; padding:10px;">No table of contents available in this PDF.</div>';
                        }
                        tocSidebar.dataset.loaded = 'true';
                    });
                }
            } else {
                tocSidebar.style.display = 'none';
            }
        }

        function renderOutline(items, container, depth) {
            items.forEach(function (item) {
                const div = document.createElement('div');
                div.className = 'toc-item toc-depth-' + Math.min(depth, 3);
                div.textContent = item.title;
                div.addEventListener('click', function () {
                    // Navigate to the destination
                    if (item.dest) {
                        // dest can be a string (named destination) or an array (explicit destination)
                        const destPromise = typeof item.dest === 'string'
                            ? pdfDoc.getDestination(item.dest)
                            : Promise.resolve(item.dest);
                        destPromise.then(function (dest) {
                            if (dest) {
                                pdfDoc.getPageIndex(dest[0]).then(function (pageIndex) {
                                    pageNum = pageIndex + 1;
                                    // In dual mode, snap to odd page
                                    if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                                        pageNum = pageNum - 1;
                                    }
                                    queueRenderPage(pageNum);
                                });
                            }
                        });
                    } else if (item.url) {
                        window.open(item.url, '_blank');
                    }
                });
                container.appendChild(div);
                if (item.items && item.items.length > 0) {
                    renderOutline(item.items, container, depth + 1);
                }
            });
        }

        document.getElementById('prev-page').addEventListener('click', onPrevPage);
        document.getElementById('next-page').addEventListener('click', onNextPage);
        document.getElementById('zoom-in').addEventListener('click', () => { onZoomIn(); debounceSave(); });
        document.getElementById('zoom-out').addEventListener('click', () => { onZoomOut(); debounceSave(); });
        document.getElementById('fit-width').addEventListener('click', () => { onFitWidth(); debounceSave(); });
        document.getElementById('fit-page').addEventListener('click', () => { onFitPage(); debounceSave(); });
        document.getElementById('toggle-toc').addEventListener('click', onToggleToc);
        document.getElementById('toggle-dual').addEventListener('click', onToggleDual);

        // Go to Page Input
        const pageInput = document.getElementById('page-num-input');
        pageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                // Handle both single page "5" and dual range "5-6" inputs
                const rawVal = pageInput.value.split('-')[0].trim();
                const val = parseInt(rawVal);
                if (val && val >= 1 && val <= pdfDoc.numPages) {
                    pageNum = val;
                    if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                        pageNum = pageNum - 1;
                    }
                    queueRenderPage(pageNum);
                } else {
                    // Reset to current
                    pageInput.value = pageNum;
                }
            }
        });

        // Load Document
        pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
            pdfDoc = pdfDoc_;
            document.getElementById('page-count').textContent = pdfDoc.numPages;
            // In dual mode, snap to odd page on initial load
            if (dualPageMode && pageNum % 2 === 0 && pageNum > 1) {
                pageNum = pageNum - 1;
            }
            renderPage(pageNum);
        });

        // --- Keyboard Navigation ---
        // --- Keyboard Navigation ---
        const pdfWrapper = document.getElementById('pdf-wrapper');
        // Make wrapper focusable
        pdfWrapper.setAttribute('tabindex', '0');
        // Focus on load so keys work immediately
        pdfWrapper.focus();

        // Re-focus wrapper when clicking on canvas/text layer
        document.getElementById('pdf-content').addEventListener('click', () => {
            pdfWrapper.focus();
        });

        pdfWrapper.addEventListener('keydown', (e) => {
            // Ignore if focus is somehow on an input (though event is scoped to wrapper, 
            // bubbles from children could trigger this if we had inputs inside, which we don't currently)

            if (e.key === 'ArrowLeft') {
                e.preventDefault(); // Prevent horizontal scrolling if any
                onPrevPage();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                onNextPage();
            }
            // Up/Down arrows will bubble/default to scrolling the container naturally
        });

        // --- Text Selection & Context - Override/Hook ---

        document.addEventListener('selectionchange', () => {
            const selection = window.getSelection();
            const text = selection.toString().trim();

            if (text && text.length > 0) {
                // Check if selection is inside pdf
                if (document.getElementById('pdf-wrapper').contains(selection.anchorNode)) {
                    // Call the shared component function
                    if (window.updateChatContext) {
                        window.updateChatContext(text);
                    }
                }
            }
        });
    </script>
</body>

</html>